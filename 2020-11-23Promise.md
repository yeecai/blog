promise

The traditional way to do asynchronous programming is setTimeout, but if your depends on the previous code, it leads to the callback hell, a callback inside the previous callback

#### The promise object

pending => resolved(fulfilled), with resolved value

â€‹				=> rejected, failed reason

- can't access the value before the state changed, for preventing used in a synchronous way.

-  once it's resolved or rejected, the state is irreversible;

- private internal reason for rejected state, private internal value for resolved state; both optional with default value *undefined*;

- it's the same to initialize a promise;

  ```javascript
  let p1 = new Promise((resolve, reject) => resolve());
  let p2 = Promise.resolve();
  ```

- try catch won't catch the error thrown by reject(), because the error is not being thrown in the synchronous execution thread but the asynchronous message queue;

  ```javascript
  try {
    Promise.reject(new Error('bar'));
  } catch(e) {
    console.log(e)
  }
  ```

- .then(), takes too callback one on resolved, one on rejected, non-functional argument will be ignored, it return a new promise instance;

- throw error in then() will return a rejected promise;

- calling then() with no callback same as a passthrough;

- then(), catch(), finally() etc. all the execution in callback will be put into message queue, executed next batch after the all synchronous code.

  ```javascript
  let p = new Promise((resolve) => {
    console.log('1: invoking resolve()');
    resolve();
    console.log('2: resolve() returns');
   });
  
  p.then(() => console.log('4: then() handler executes'));
  
  console.log('3: synchronousResolve() returns');
  // 1 2 3 4
  ```

  ```javascript
  let p = new Promise((resolve) => {
   setTimeout(() => {
       console.log('1: invoking resolve()');
    	resolve();
   	 console.log('2: resolve() returns');
    })
   });
  
  p.then(() => console.log('4: then() handler executes'));
  
  console.log('3: synchronousResolve() returns');
  // 3 1 2 4
  ```

  

catch()

catch the error and return a promise instance

finally()

executed when the state is changed, whether resolved or reject. deduplicate the code between onResolve or onRejected;  return a new promise instance, return a pending promise will consided as a passthrough for the initial promise once it's resolved;

race()

.all()

promise cancellation and notification

How to cancel a promise, delay the target promise's resolve(), and create a cancelToken instance class to provide a callback to trigger clearTimeout(id) to remove the delayed target's timer, then prevent it to resolve.

- one of the reason there's not Promise.cancelI() and no Promise.notify is it increase the complication of promise chaining and composition, i.g. what if a promise in *Promise.all()* cancels, and when should notify if the promise still in chaining.

```javascript
<button id="start">Start</button>
<button id="cancel">Cancel</button>

<script>
class CancelToken {
 constructor(cancelFn) {
  this.promise = new Promise((resolve, reject) => {
   cancelFn(() => {
    setTimeout(console.log, 0, "delay cancelled");
    resolve();
   });
  });
 }
}

const startButton = document.querySelector('#start');
const cancelButton = document.querySelector('#cancel');

function cancellableDelayedResolve(delay) {
 setTimeout(console.log, 0, "set delay");
 
 return new Promise((resolve, reject) => {
  const id = setTimeout((() => {
   setTimeout(console.log, 0, "delayed resolve");
   resolve();
  }), delay);
  
  const cancelToken = new CancelToken((cancelCallback) => 
    cancelButton.addEventListener("click", cancelCallback));
  
  cancelToken.promise.then(() => clearTimeout(id));
 });
}
    
```





async/await

